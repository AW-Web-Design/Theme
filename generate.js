const StyleDictionary = require("style-dictionary");
const fs = require("fs");
const _ = require("lodash");
const Color = require("tinycolor2");

const Config = require("./config.json");

const minifyDictionary = obj => {
  const toRet = {};
  if (Object.keys(obj).includes("value")) {
    return obj.value;
  }
  // eslint-disable-next-line no-restricted-syntax
  for (const name in obj) {
    if (Object.keys(obj).includes(name)) {
      toRet[name] = minifyDictionary(obj[name]);
    }
  }

  return toRet;
};

const nestedJson = dictionary => {
  if (dictionary.allProperties[0].name === "neutral_base") {
    const properties = dictionary.properties;

    properties.color.neutrals = properties.color.neutral_base;
    delete properties.color.neutral_base;

    return `const tokens = ${JSON.stringify(minifyDictionary(properties[Object.keys(properties)[0]]), null, 2)}

    export default tokens;
    `;
  }

  let output = dictionary.properties;

  if (output.color) {
    output = output.color;
  }
  if (output.modes) {
    output = output.modes;
  }
  if (output.dark) {
    output = output.dark;
  }
  if (output.light) {
    output = output.light;
  }
  if (output.subthemes) {
    output = output.subthemes;
  }
  if (output.size) {
    output = output.size;
  }

  if (output.breakpoints) {
    const minified = minifyDictionary(output.breakpoints);

    return `const tokens = ${JSON.stringify(
      {
        breakpoints: Object.keys(minified).map(key => minified[key]),
      },
      null,
      2,
    )}

    export default tokens;
    `;
  }

  return `const tokens = ${JSON.stringify(minifyDictionary(output), null, 2)}

  export default tokens;
  `;
};

StyleDictionary.registerFormat({
  name: "custom/nested/json",
  formatter: nestedJson,
});

StyleDictionary.registerFormat({
  name: "custom/nested/json/subthemes",
  formatter: _.template(fs.readFileSync("./templates/subthemes.template")),
});

StyleDictionary.registerFormat({
  name: "scss/variables",
  formatter(dictionary) {
    const header = `/* ${this.header} */\n /* DO NOT EDIT Generated by Design tokens */\n`;
    return `${header}${dictionary.allProperties.map(prop => `$${prop.name}: ${prop.value};`).join("\n")}\n`;
  },
});

StyleDictionary.registerFormat({
  name: "custom/subtheme_tokens",
  formatter: _.template(fs.readFileSync("./templates/subthemes_tokens.template")),
});

StyleDictionary.registerFormat({
  name: "custom/intent_tokens",
  formatter: _.template(fs.readFileSync("./templates/intent_tokens.template")),
});

StyleDictionary.registerFormat({
  name: "custom/neutrals_tokens",
  formatter: _.template(fs.readFileSync("./templates/neutrals_tokens.template")),
});

StyleDictionary.registerTransform({
  name: "custom/makeSubtheme",
  type: "value",
  matcher(prop) {
    return prop.attributes.type === "subthemes" || prop.attributes.type === "intents";
  },
  transformer(prop) {
    const color = Color(prop.value);
    const subtheme = {};
    const paletteLight = [];
    const paletteDark = [];

    const colorBase = Color("#222222");
    const colorLight = Color("#FFF");

    paletteLight.push(color.toHexString());
    paletteLight.push(Color.mix(color, colorBase, 10).toHexString());
    paletteLight.push(Color.mix(color, colorLight, 10).toHexString());
    paletteLight.push(Color.mix(color, colorLight, 35).toHexString());
    paletteLight.push(Color.mix(color, colorLight, 80).toHexString());

    paletteDark.push(color.toHexString());
    paletteDark.push(Color.mix(color, colorLight, 10).toHexString());
    paletteDark.push(Color.mix(color, colorBase, 10).toHexString());
    paletteDark.push(Color.mix(color, colorBase, 35).toHexString());
    paletteDark.push(Color.mix(color, colorBase, 80).toHexString());

    subtheme.light = paletteLight;
    subtheme.dark = paletteDark;

    return subtheme;
  },
});

StyleDictionary.registerTransform({
  name: "color/makeNeutrals",
  type: "value",
  matcher(prop) {
    // this is an example of a possible filter (based on the "cti" values) to show how a "matcher" works
    return prop.attributes.type === "neutral_base";
  },
  transformer(prop) {
    const colorBase = Color(prop.value);
    const colorLight = Color("#FFFFFF");
    const neutrals = {};
    const paletteLight = [];
    const paletteDark = [];
    const percentages = [0, 2, 3, 5, 8, 10, 12, 16, 20, 24, 26, 30, 35, 40, 45, 52, 60, 70, 80, 90, 100];

    percentages.forEach(mixPercentage => {
      paletteLight.push(Color.mix(colorLight, colorBase, mixPercentage).toHexString());
      paletteDark.push(Color.mix(colorBase, colorLight, mixPercentage).toHexString());
    });

    neutrals.light = paletteLight;
    neutrals.dark = paletteDark;

    return neutrals;
  },
});

const generate = (brand = "default") => {
  const ConfigWithSource = Config;
  ConfigWithSource.source = [`src/${brand.toLowerCase()}/**/*.json`];

  const BaseStyleDictionary = StyleDictionary.extend(ConfigWithSource);

  BaseStyleDictionary.buildAllPlatforms();
};

const argv = process.argv.slice(2);

if (argv[0] === "--brand") {
  if (argv[1]) {
    // eslint-disable-next-line no-console
    console.log(`\nBuilding ${argv[1]} tokens...`);
    generate(argv[1]);
  } else {
    throw new Error("Must specify brand when using --brand argument");
  }
} else {
  // eslint-disable-next-line no-console
  console.log("\nBuilding Default tokens...");
  generate();
}
